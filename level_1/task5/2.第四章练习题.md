2.第四章练习题

如下合约中，test 返回什么? 10
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;
contract Demo {
    //当给返回值赋值后，并且有个return，以最后的return为主
    function test() public pure returns (uint256 mul) {
        uint256 a = 10;
        mul = 100;
        return a;
    }
}


函数参数使用时候有哪些需要注意的？

- 引用类型需要 memory/calldata
引用类型的存储位置：
对于引用类型（如数组、结构体和字符串），在函数参数中必须指定存储位置。可以使用 memory 或 calldata：
memory  ：表示在函数执行期间存储在内存中，适用于可变大小的数组和结构体。
calldata：表示数据在调用时不可修改，适用于外部函数参数，通常用于节省 gas。
- 函数参数可以当作为本地变量，也可用在等号左边被赋值。 (但要注意，如果是引用类型，赋值会影响原始数据（如果是 memory 类型则不会影响原始数据）)
- 外部函数不支持多维数组，如果原文件加入 p ragma abicoder v2; 可以启用 ABI v2 版编码功能，这此功能可用。
	外部函数不支持多维数组作为参数。如果需要传递多维数组，可以考虑使用一维数组并在函数内部进行处理。
	如果在合约中使用 pragma abicoder v2;，则可以启用 ABI v2 编码功能，这样可以支持更复杂的数据结构，包括多维数组和嵌套结构体。


创建一个 Utils 合约，其中有 sum 方法，传入任意数量的数组，都可以计算出求和结果。
```
pragma solidity ^0.8.20;

contract Utils {
	function sum(uint[] memory num) public pure returns (uint total) {
		total = 0;
		for (uint i=0; i<num.length; i++){
			total += num[i];
		}
	}
}
```

函数既可以定义在合约内部，也可以定义在合约外部，两种方式的区别是什么？

合约之外的函数（也称为“自由函数”）始终具有隐式的 internal 可见性。 
	它们的代码包含在所有调用它们合约中，类似于内部库函数。
	在合约之外定义的函数仍然在合约的上下文内执行。
	他们仍然可以访问变量 this ，也可以调用其他合约，将其发送以太币或销毁调用它们合约等其他事情。
与在合约中定义的函数的主要区别为：自由函数不能直接访问存储变量和不在他们的作用域范围内函数。
外部函数调用的 gas 费用通常比内部函数调用高，因为它们涉及到外部调用的开销。



函数的构造函数有什么特点？

它仅能在智能合约部署的时候调用一次，创建之后就不能再次被调用。
构造函数是可选的，只允许有一个构造函数，这意味着不支持重载。（普通函数支持重载）
在合约创建的过程中，它的代码还是空的，所以直到构造函数执行结束，我们都不应该在其中调用合约自己的函数。
(可以直接写函数名调用，但是不推荐调用，不可以通过 this 来调用函数，因为此时真实的合约实例还没有被创建。)


构造函数有哪些用途？

用来设置管理账号，Token 信息等可以自定义，并且以后永远不需要修改的数据。
可以用来做初识的权限设置，避免后续没办法 owner/admin 地址。


合约内调用外部有哪些？

也可以使用表达式 进行调用
1. this.g(8);  this 关键字调用合约的函数 g
2. c.g(2);  其中 c 是合约实例， 通过该实例调用合约 c 中的函数 g，
这两种方式调用函数，称为“外部调用”，
	它是通过消息调用来进行，而不是直接的代码跳转。
	请注意，不可以在构造函数中通过 this 来调用函数，因为此时真实的合约实例还没有被创建。



从一个合约到另一个合约的函数调用会创建交易么？

从一个合约到另一个合约的函数调用不会创建自己的交易, 它是作为整个交易的一部分的消息调用。	
这意味着：
同一交易上下文：当合约 A 调用合约 B 的函数时，这个调用是在合约 A 的交易上下文中进行的。合约 B 的函数执行是合约 A 交易的一部分，而不是一个独立的交易。
Gas 费用：合约 A 调用合约 B 的函数会消耗 gas，但这部分 gas 是从合约 A 的交易中扣除的。调用合约 B 的函数不会产生额外的交易费用。
状态变化：合约 B 的状态变化（如果有的话）会在合约 A 的交易中被记录。合约 B 的状态变化不会单独提交到区块链，而是作为合约 A 的交易的一部分。



调用函数并转帐如何实现
调用一个合约的函数并同时转账以太币可以通过使用 call 语法或直接调用合约的函数来实现
feed.info{value: 10, gas: 800}(2);
注意 feed.info{value: 10, gas: 800} 仅（局部地）设置了与函数调用一起发送的 Wei 值和 gas 的数量，只有最后的小括号才执行了真正的调用。 因此， feed.info{value: 10, gas: 800} 是没有调用函数的， value 和 gas 设置是无效的。


extcodesize 操作码会检查要调用的合约是否确实存在，有哪些特殊情况？

低级 call 调用，会绕过检查
预编译合约的时候(合约正在被创建)，外部账户（EOA）,合约被销毁, 合约的代码在调用时被修改 也会绕过检查。

在 Solidity 和以太坊的 EVM（以太坊虚拟机）中，extcodesize 操作码用于检查一个地址上是否存在合约代码。它返回指定地址的代码大小（以字节为单位）。如果地址上没有合约代码，extcodesize 返回 0。这在合约调用和安全性检查中非常有用。



与其他合约交互时候有什么需要注意的？

任何与其他合约的交互都会产生潜在危险，尤其是在不能预先知道合约代码的情况下。
小心这个交互调用在返回之前再回调我们的合约，这意味着被调用合约可以通过它自己的函数改变调用合约的状态变量。 一个建议的函数写法是，例如，在合约中状态变量进行各种变化后再调用外部函数，这样，你的合约就不会轻易被滥用的重入攻击 (reentrancy) 所影响


public 既可以被当作内部函数也可以被当作外部函数。使用时候有什么注意的？
如果想将一个函数当作内部函数使用，就用 f 调用，如果想将其当作外部函数，使用 this.f 


pure 函数中，哪些行为被视为读取状态。

读取状态变量。
这也意味着读取 immutable 变量也不是一个 pure 操作。
访问 address(this).balance 或 <address>.balance
访问 block，tx， msg 中任意成员 （除 msg.sig 和 msg.data 之外）。
调用任何未标记为 pure 的函数。
使用包含特定操作码的内联汇编。
TODO: 这个不了解，需要用例子加深印象。
使用操作码 STATICCALL , 这并不保证状态未被读取, 但至少不被修改。


pure 函数发生错误时候，有什么需要注意的？

如果发生错误，pure 函数可以使用 revert() 和 require() 函数来还原潜在的状态更改。
还原状态更改不被视为 状态修改, 因为它只还原以前在没有 view 或 pure 限制的代码中所做的状态更改,
 并且代码可以选择捕获 revert 并不传递还原。
 这种行为也符合 STATICCALL 操作码。


 view 函数中，哪些行为视为修改状态。

修改状态变量。
触发事件。
创建其它合约。
使用 selfdestruct。
通过调用发送以太币。
调用任何没有标记为 view 或者 pure 的函数。
使用底层调用
(TODO:这里是 call 操作么？)
使用包含某些操作码的内联程序集。


pure/view/payable/这些状态可变性的类型转换是怎么样的？

pure    函数可以转换为 non-payable 函数 + view函数
view    函数可以转换为 non-payable 函数
payable 函数可以转换为 non-payable 函数
其他的转换则不可以。


使用 return 时，有哪些需要注意的？

函数返回类型不能为空 —— 如果函数类型不需要返回，则需要删除整个 returns (<return types>) 部分。
函数可能返回任意数量的参数作为输出。函数的返回值有两个关键字，一个是 returns,一个是 return;
returns 是在函数名后面的，用来标示返回值的数量，类型，名字信息。
return 是在函数主体内，用于返回 returns 指定的数据信息
如果使用 return 提前退出有返回值的函数， 必须在用 return 时提供返回值。
非内部函数有些类型没法返回，比如限制的类型有：多维动态数组、结构体等。
解构赋值一个函数返回多值时候，元素数量必须一样。


函数的签名的逻辑是什么？为什么函数可以重载？

核心: bytes4(keccak256(bytes("transfer(address,uint256)")))
函数签名被定义为基础原型的规范表达，而基础原型是函数名称加上由括号括起来的参数类型列表，参数类型间由一个逗号分隔开，且没有空格。



函数重载需要怎么样实现？

这些相同函数名的函数，参数(参数类型或参数数量)必须不一样。，因为只有这样才能签出来不同的函数选择器。
如果两个外部可见函数仅区别于 Solidity 内的类型，而不是它们的外部类型则会导致错误。很难理解，需要看例子。


函数重载的参数匹配原理

通过将当前范围内的函数声明与函数调用中提供的参数相匹配，这样就可以选择重载函数。
如果所有参数都可以隐式地转换为预期类型，则该函数作为重载候选项。如果一个匹配的都没有，解析失败。
返回参数不作为重载解析的依据。


 function f(uint8 val) public pure returns (uint8 out) 和 
 function f(uint256 val) public pure returns (uint256 out) 是合法的函数重载么？

不是的。
在 Remix 里,部署 A 合约，会将两个方法都渲染出来，调用 f(50)/f(256) 都可以。
但是实际调用里，在其他合约内调用 f(50) 会导致类型错误，因为 50 既可以被隐式转换为 uint8 也可以被隐式转换为 uint256。 
另一方面，调用 f(256) 则会解析为 f(uint256) 重载，因为 256 不能隐式转换为 uint8。


函数修改器的意义是什么？有什么作用？

意义:我们可以将一些通用的操作提取出来，包装为函数修改器，来提高代码的复用性，改善编码效率。是函数高内聚，低耦合的延伸。
作用: modifier 常用于在函数执行前检查某种前置条件。
比如地址对不对，余额是否充足，参数值是否允许等条件
修改器内可以写逻辑
特点: modifier 是一种合约属性，可被继承，同时还可被派生的合约重写(override)。（修改器 modifier 是合约的可继承属性，并可能被派生合约覆盖 , 但前提是它们被标记为 virtual）。
_ 符号可以在修改器中出现多次，每处都会替换为函数体。



Solidity 有哪些全局的数学和密码学函数？

数学函数：
	addmod(uint x, uint y, uint k) returns (uint)
	计算 (x + y) % k，加法会在任意精度下执行，并且加法的结果即使超过 2**256 也不会被截取。从 0.5.0 版本的编译器开始会加入对 k != 0 的校验（assert）。
	mulmod(uint x, uint y, uint k) returns (uint)
	计算 (x * y) % k，乘法会在任意精度下执行，并且乘法的结果即使超过 2**256 也不会被截取。从 0.5.0 版本的编译器开始会加入对 k != 0 的校验（assert）。
	
密码学函数：
	keccak256((bytes memory) returns (bytes32) 它是以太坊的主要哈希算法，常用于生成地址、签名和验证数据完整性。
	计算 Keccak-256 哈希，之前 keccak256 的别名函数 sha3 在 0.5.0 中已经移除。。

	sha256(bytes memory) returns (bytes32)
	计算参数的 SHA-256 哈希。

	ripemd160(bytes memory) returns (bytes20) RIPEMD-160 是一种加密哈希函数，广泛用于生成短哈希值，尤其是在比特币和其他区块链技术中。
	计算参数的 RIPEMD-160 哈希。

	ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)
	从以太坊签名中恢复公钥地址。它通常用于验证消息的签名，确保消息确实是由某个特定地址的私钥签名的。这个函数在实现身份验证、交易确认和其他安全相关功能时非常有用。

	利用椭圆曲线签名恢复与公钥相关的地址，错误返回零值。  
	函数参数对应于 ECDSA 签名的值:
	r = 签名的前 32 字节
	s = 签名的第 2 个 32 字节
	v = 签名的最后一个字节
	ecrecover 返回一个 address, 而不是 address payable。